<template>
  <portal
    :to="idFrom"
    :disabled="!fullScreenMode"
  >
    <div
      :id="idFrom"
      class="dash-table-v2-container"
      :style="{
        ...customStyle,
        height: Math.round(sizeFrom.height) - 42 + 'px',
        width: Math.round(sizeFrom.width - 4) + 'px',
      }"
      :class="customClass"
      v-bind="$attrs"
    >
      <div
        v-if="title"
        class="title"
        v-text="title"
      />
      <dash-table-control
        v-if="activeButtons.length > 0"
        :write-status="writeStatus"
        :active-buttons="activeButtons"
        @action="execute"
      />
      <div :style="`height: ${tableHeight}`">
        <div
          v-if="fullScreenMode"
          :ref="idFrom"
          class="editable-table"
        />
        <div
          v-else
          :ref="idFrom"
          class="editable-table"
        />
      </div>
      <v-dialog
        v-model="isDownloadModal"
        width="350"
      >
        <v-card class="report-card">
          <v-card-title
            class="card-title justify-space-between"
            :style="{ background: theme.$main_bg, color: theme.$main_text }"
          >
            <div>
              <v-icon
                :style="{ color: theme.$main_text }"
                class="download-icon"
              >
                {{ mdiDownload }}
              </v-icon>
              Отчет
            </div>
            <div>
              <v-btn
                icon
                :color="theme.$main_text"
                @click="isDownloadModal = false"
              >
                <v-icon>{{ mdiClose }}</v-icon>
              </v-btn>
            </div>
          </v-card-title>

          <v-card-text
            class="card-text pt-4 d-flex justify-center"
            :style="{ background: theme.$secondary_bg, color: theme.$main_text }"
          >
            <div class="row align-stretch">
              <div
                v-for="(item, index) in downloadFiles"
                :key="index"
                class="col-6"
              >
                <v-btn
                  small
                  text
                  :color="theme.$main_text"
                  class="d-flex align-center"
                  @click="execute(index)"
                >
                  <v-icon :color="theme.$main_text">
                    {{ mdiDownload }}
                  </v-icon>
                  <span>
                    Скачать {{ item }}
                  </span>
                </v-btn>
              </div>
            </div>
          </v-card-text>
        </v-card>
      </v-dialog>
    </div>
  </portal>
</template>

<script>
import { TabulatorFull as Tabulator } from 'tabulator-tables';
import {
  mdiFilter,
  mdiDownload,
  mdiClose,
} from '@mdi/js';
import { throttle } from '@/js/utils/throttle';

// eslint-disable-next-line func-names
const colorFixed = function (cell) {
  cell.getElement().style.backgroundColor = this.sanitizeHTML(cell.getValue());

  return '&nbsp;';
};

// eslint-disable-next-line func-names
const headerFilter = function (cell, onRendered, success, cancel /* editorParams */) {
  // const field = cell.getField();
  const container = document.createElement('span');
  container.classList.add('dash-table-v2-container__filter-container');

  // create and style select element
  const select = document.createElement('select');
  select.classList.add('dash-table-v2-container__filter-select');
  ['', '>', '<', '=', '>=', '<=', '!='].forEach((item) => {
    const option = document.createElement('option');
    option.classList.add('dash-table-v2-container__filter-select-option');
    option.value = item;
    option.textContent = item;
    select.appendChild(option);
  });
  select.placeholder = 'Знак';
  select.style.padding = '4px';
  select.style.boxSizing = 'border-box';

  // create and style text input element
  const textInput = document.createElement('input');
  textInput.type = 'text';
  textInput.classList.add('dash-table-v2-container__filter-input');
  textInput.placeholder = 'Значение';

  let selectValue = '';
  let textValue = '';

  function buildValues() {
    success({
      selectValue,
      textValue,
    });
  }

  function keypress(e) {
    if (e.keyCode === 13) {
      buildValues();
    }

    if (e.keyCode === 27) {
      cancel();
    }
  }

  function updateTextValue(value) {
    textValue = Number.isNaN(+value) ? value : +value;
  }

  // add event listeners
  select.addEventListener('change', (e) => {
    selectValue = e.target.value;
    if (textValue !== '') {
      buildValues();
    }
  });
  select.addEventListener('keydown', (e) => {
    selectValue = e.target.value;
    if (textValue !== '') {
      keypress(e);
    }
  });

  textInput.addEventListener('input', (e) => {
    updateTextValue(e.target.value);
    buildValues();
  });

  textInput.addEventListener('keydown', (e) => {
    updateTextValue(e.target.value);
    keypress(e);
  });

  // append elements to container
  container.appendChild(select);
  container.appendChild(textInput);

  return container;
};

// eslint-disable-next-line func-names
const headerFilterFn = function (headerValue, rowValue /* rowData, */ /* filterParams */) {
  const compare = headerValue.selectValue;
  const filterValue = headerValue.textValue;
  switch (compare) {
    case '>':
      return rowValue > filterValue;
    case '<':
      return rowValue < filterValue;
    case '=':
      return rowValue === filterValue;
    case '>=':
      return rowValue >= filterValue;
    case '<=':
      return rowValue <= filterValue;
    case '!=':
      return rowValue !== filterValue;
    default:
      return true;
  }
};

export default {
  name: 'DashTableV2',
  props: {
    fullScreenMode: {
      type: Boolean,
      default: false,
    },
    customStyle: {
      type: Object,
      default: () => ({}),
    },
    customClass: {
      type: String,
      default: '',
    },
    title: {
      type: String,
      default: '',
    },
    dataRestFrom: {
      type: Array,
      default: () => ([]),
    },
    idFrom: {
      type: String,
      required: true,
    },
    idDashFrom: {
      type: String,
      required: true,
    },
    searchSchema: {
      type: Object,
      default: () => ({}),
    },
    writeStatus: {
      type: String,
      default: '',
    },
    sizeFrom: {
      type: Object,
      required: true,
    },
  },
  data() {
    return {
      mdiFilter,
      mdiDownload,
      mdiClose,
      // tabulator: null, // variable to hold your table
      tableData: [],
      isLoadFromFile: false,
      activeButtons: [],
      headerFilters: {},
      test: false,
      // TODO: Перенести в настройки через библиотеку примитивов
      options: {
        frozenRows: false,
        fixedColumns: ['_time'],
        selectable: false,
        selectColumn: false,
        paginationSizeSelector: [100, 500, 1000, true],
        paginationCounter: 'rows',
        movableColumns: true,
        defaultFilterAllColumns: true,
      },
      actions: [
        { name: 'click', capture: [] },
        { name: 'mouseover', capture: [] },
      ],
      isDownloadModal: false,
      downloadFiles: {
        downloadCSV: 'CSV',
        downloadJSON: 'JSON',
        downloadXLSX: 'XLSX',
        downloadHTML: 'HTML',
      },
    };
  },
  computed: {
    isEdit() {
      return this.$store.state[this.idDashFrom].editMode;
    },
    fields() {
      return this.getOptions?.fieldList || [];
    },
    theme() {
      return this.$store.getters.getTheme;
    },
    dashFromStore() {
      return this.$store.state[this.idDashFrom][this.idFrom];
    },
    getOptions() {
      return this.dashFromStore.options;
    },
    tableHeight() {
      let offset = this.activeButtons?.length > 0 ? 38 : 0;
      offset += this.title ? 33 : 0;
      return `calc(100% - ${offset}px)`;
    },
    columnOptions() {
      const columnOptions = {};
      Object.keys(this.searchSchema).forEach((column) => {
        columnOptions[column] = {
          headerFilter: this.defaultFilterAllColumns,
          headerMenu: true,
          frozen: this.frozenColumns.includes(column),
        };
      });
      return columnOptions;
    },
    columns() {
      const defaultColumns = this.options.selectColumn
        ? [
          {
            title: 'Выделение',
            formatter: 'rowSelection',
            titleFormatter: 'rowSelection',
            width: 50,
            hozAlign: 'center',
            headerHozAlign: 'center',
            headerSort: false,
            cellClick(e, cell) {
              cell.getRow().toggleSelect();
            },
          },
        ]
        : [];
      const fields = this.idDashFrom === 'reports' ? Object.keys(this.searchSchema) : this.fields;
      if (this.columnOptions && Object.keys(this.columnOptions).length) {
        return fields.reduce((acc, key) => {
          if (key === '_columnOptions') {
            return acc;
          }

          const options = this.columnOptions[key];
          const column = {
            field: key,
            title: options?.title || key,
            resizable: 'header',
            frozen: options?.frozen || false,
            headerFilter: options?.headerFilter ? headerFilter : false,
            headerFilterLiveFilter: false,
            headerFilterFunc: this.options.defaultFilterAllColumns ? headerFilterFn : false,
            editor: options?.editor || false,
            headerMenu: options?.headerMenu && this.isEdit ? this.headerMenu : false,
            cellClick: this.cellClickEvent,
            minWidth: options?.minWidth || (options?.headerFilter ? 150 : 80),
          };

          if (options?.formatter) {
            column.formatter = options.formatter === 'color' ? colorFixed : options.formatter;
          }

          if (options?.formatter === 'tickCross') {
            column.headerFilterParams = { tristate: true };
            column.headerFilterEmptyCheck = (value) => value === null;
          }

          if (options?.editor === 'list' && options.editorParams) {
            column.editorParams = options.editorParams;
            column.headerFilter = 'input';
          }

          return [...acc, column];
        }, defaultColumns);
      }

      return fields.reduce((acc, key) => {
        const column = {
          field: key,
          title: key,
          resizable: 'header',
          editor: this.searchSchema[key] === 'BOOLEAN' ? 'tickCross' : true,
          headerMenu: this.isEdit ? this.headerMenu : false,
          headerFilter: this.options.defaultFilterAllColumns ? headerFilter : false,
          headerFilterFunc: this.options.defaultFilterAllColumns ? headerFilterFn : false,
          cellClick: this.cellClickEvent,
        };

        if (this.searchSchema[key] === 'BOOLEAN') {
          column.formatter = 'tickCross';
          column.headerFilterParams = { tristate: true };
          column.headerFilterEmptyCheck = (value) => value === null;
        }

        return [...acc, column];
      }, defaultColumns);
    },
    events() {
      return this.getEvents({
        idDash: this.idDashFrom,
        event: 'OnDataCompare',
        element: this.idFrom,
      });
    },
    getTokens() {
      return this.$store.state[this.idDashFrom].tockens
        .filter((el) => el.elem === this.idFrom) || [];
    },
    // options
    frozenColumns() {
      return this.getOptions?.frozenColumns || [];
    },
    visibleColumns() {
      return this.getOptions?.titles || [];
    },
    selectableRow() {
      return !!this.getOptions?.selectableRow;
    },
    movableColumns() {
      if (this.isEdit) {
        return this.getOptions?.movableColumns || false;
      }
      return false;
    },
    defaultFilterAllColumns() {
      return this.getOptions?.defaultFilterAllColumns || true;
    },
    saveMovedColumnPosition() {
      return !!this.getOptions?.saveMovedColumnPosition;
    },
  },
  watch: {
    searchSchema: {
      handler(value) {
        if (Object.keys(value)?.length > 0 && this.idDashFrom !== 'reports') {
          const isUpdatedValue = this.fields?.length > 0 && this.saveMovedColumnPosition
            ? this.checkFieldList(Object.keys(value), structuredClone(this.fields))
            : true;
          if (isUpdatedValue) {
            this.updateFieldListInStore(Object.keys(value));
          }
        }
      },
      deep: true,
    },
    dataRestFrom: {
      handler(val, oldVal) {
        if (val?.length > 0 && this.searchSchema) {
          if (JSON.stringify(val) !== JSON.stringify(oldVal)) {
            this.$nextTick(() => {
              this.$nextTick(() => {
                this.createTable();
              });
            });
          }
          this.updateDataInTable(val);
          this.onDataCompare();
        }
      },
      deep: true,
    },
    columnOptions: {
      handler() {
        this.updateColumnDefinition();
      },
      deep: true,
    },
    fullScreenMode(val, oldVal) {
      if (val !== oldVal) {
        this.redrawTable();
      }
    },
    frozenColumns: {
      handler(val, oldVal) {
        if (JSON.stringify(val) !== JSON.stringify(oldVal)) {
          // this.redrawTable();
          this.tabulator.redraw();
        }
      },
      deep: true,
    },
    selectableRow(val, oldVal) {
      if (val !== oldVal) {
        this.redrawTable();
      }
    },
    movableColumns(val, oldVal) {
      if (val !== oldVal) {
        this.redrawTable();
      }
    },
    saveMovedColumnPosition(val, oldVal) {
      if (val !== oldVal) {
        this.redrawTable();
      }
    },
    defaultFilterAllColumns(val, oldVal) {
      if (val !== oldVal) {
        this.updateColumnDefinition();
      }
    },
    isEdit() {
      this.$nextTick(() => {
        this.$nextTick(() => {
          this.createTable();
          this.updateDataInTable(this.dataRestFrom);
        });
      });
    },
  },
  mounted() {
    if (this.dataRestFrom?.length > 0) {
      if (this.fields?.length === 0 && Object.keys(this.searchSchema)?.length > 0) {
        this.updateFieldListInStore(Object.keys(this.searchSchema));
      }
      this.setAction(this.searchSchema);
      this.redrawTable(true);
    }
  },
  created() {
    this.createTable = throttle(this.createTable, 500);
    this.redrawTable = throttle(this.redrawTable, 500);
  },
  beforeDestroy() {
    this.destroyTable();
  },
  methods: {
    checkFieldList(arr, oldArr) {
      const sortedOldArr = [...oldArr].sort().join(',');
      const sortedArr = [...arr].sort().join(',');
      return sortedArr !== sortedOldArr;
    },
    openDownloadModal() {
      this.isDownloadModal = true;
    },
    getPosition(el, offset = 0) {
      let xPosition = 0;
      let yPosition = 0;

      while (el) {
        if (el.tagName === 'BODY') {
          // deal with browser quirks with body/window/document and page scroll
          const xScrollPos = el.scrollLeft || document.documentElement.scrollLeft;
          const yScrollPos = el.scrollTop || document.documentElement.scrollTop;

          xPosition += (el.offsetLeft - xScrollPos + el.clientLeft);
          yPosition += (el.offsetTop - yScrollPos + el.clientTop);
        } else {
          xPosition += (el.offsetLeft - el.scrollLeft + el.clientLeft);
          yPosition += (el.offsetTop - el.scrollTop + el.clientTop);
        }

        el = el.offsetParent;
      }
      return {
        x: xPosition,
        y: yPosition - offset,
      };
    },
    rowFormatter(row) {
      this.events.forEach((event) => {
        const type = event.prop[0];
        const color = event.value[0];
        const {
          compare,
          column: targetField,
          row: compareField,
        } = event;
        row.getCells().forEach((cell, index, arr) => {
          const cellField = cell.getColumn().getField();
          if (cellField === targetField) {
            const cellValue = cell.getValue();
            const secondCell = arr.find((el) => el.getColumn().getField() === compareField);
            const secondCellValue = secondCell ? secondCell.getValue() : compareField;
            if (compare === 'equals' && `${cellValue}` === `${secondCellValue}`) {
              this.changeColorElement({ cell, row }, type, color);
            } else if (compare === 'over' && cellValue > secondCellValue) {
              this.changeColorElement({ cell, row }, type, color);
            } else if (compare === 'less' && cellValue < secondCellValue) {
              this.changeColorElement({ cell, row }, type, color);
            }
          }
        });
      });
      return '';
    },
    changeColorElement({ cell, row }, type, color) {
      if (type === 'cellcolor') {
        this.changeCellColor(cell, color);
      } else if (type === 'rowcolor') {
        this.changeRowColor(row, color);
      } else if (type === 'colcolor') {
        this.changeColumnColor(cell.getColumn(), color);
      }
    },
    changeColumnColor(column, color) {
      column.getCells().forEach((el) => {
        el.getElement().style.backgroundColor = color;
      });
    },
    changeRowColor(row, color) {
      row.getElement().classList.add('on-data-compare-color');
      row.getElement().style.backgroundColor = color;
    },
    changeCellColor(cell, color) {
      cell.getElement().style.backgroundColor = color;
    },
    updateDataInTable(data) {
      this.tableData = structuredClone(data);
      this.isLoadFromFile = false;
      if (this.tabulator) {
        setTimeout(() => {
          this.tabulator.setData(this.dataRestFrom);
        }, 100);
      }
    },
    redrawTable(isFullRedraw) {
      this.$nextTick(() => {
        this.$nextTick(() => {
          this.updateColumnDefinition();
          this.createTable();
          this.updateDataInTable(this.dataRestFrom);
        });
      });
    },
    async updateColumnDefinition() {
      if (this.tabulator && Object.keys(this.dataRestFrom).length > 0) {
        const tabulatorColumns = this.tabulator.getColumns();
        const columnDefinition = this.columns.reduce((acc, col) => {
          const colField = col.field;
          // eslint-disable-next-line no-underscore-dangle
          const tCol = tabulatorColumns.find((item) => item?._column.field === colField);
          if (!colField || !tCol) {
            return [
              ...acc,
              col,
            ];
          }
          return [
            ...acc,
            {
              ...col,
              // eslint-disable-next-line no-underscore-dangle
              width: tCol._column.width,
            },
          ];
        }, []);

        this.tabulator.setColumns(columnDefinition);
      }
    },
    createTable() {
      if (this.tabulator) {
        this.tabulator.destroy();
        this.tabulator = null;
      }
      this.tabulator = new Tabulator(this.$refs[this.idFrom], {
        addRowPos: 'top',
        placeholder: 'No Data Available', // display message to user on empty table
        popupContainer: `#${this.idFrom}`,
        maxHeight: '100%',
        height: '100%',
        layout: 'fitDataFill',
        frozenRows: this.options.frozenRows,
        // rowHeight: this.options.rowHeight,
        selectable: this.selectableRow ? 1 : false,
        rowFormatter: this.rowFormatter,
        renderVerticalBuffer: 50,
        persistence: {
          columns: ['width', 'frozen', 'visible'],
          sort: true,
          filter: true,
        },
        persistenceID: this.idFrom,
        data: this.tableData, // link data to table
        reactiveData: false, // enable data reactivity

        // define table columns
        autoColumns: this.isLoadFromFile,
        columns: this.columns,
        pagination: 'local',
        paginationSize: true,
        paginationSizeSelector: this.options.paginationSizeSelector,
        paginationCounter: this.options.paginationCounter,
        movableColumns: this.movableColumns,
        // history
        history: true,
        persistenceWriterFunc: this.persistenceWriterFunc,
        persistenceReaderFunc: this.persistenceReaderFunc,
      });
      this.tabulator.on('columnVisibilityChanged', (/* column, visible */) => {
        // TODO: Добавить переключение видимых колонок с сохранением в store
      });
      this.tabulator.on('columnMoved', (column, columns) => {
        if (this.saveMovedColumnPosition) {
          const fields = columns.map((el) => el.getField());
          this.updateFieldListInStore(fields);
        }
      });
    },
    updateFieldListInStore(fieldList) {
      if (!this.fields) {
        this.$store.commit('setState', [{
          object: this.getOptions,
          prop: 'fieldList',
          value: [],
        }]);
      }
      this.$store.commit('setState', [{
        object: this.getOptions,
        prop: 'fieldList',
        value: fieldList,
      }]);
    },
    headerMenu() {
      const menu = [];
      const columns = this.tabulator.getColumns();

      // eslint-disable-next-line no-restricted-syntax
      for (const column of columns) {
        // create checkbox element using font awesome icons
        const icon = document.createElement('span');
        icon.style.fontSize = '20px';
        // icon.classList.add('FontIcon');
        icon.classList.add('eva-basic_check_big');
        icon.classList.add(column.isVisible() ? 'eva-basic_checkbox_checked' : 'eva-basic_checkbox');

        // build label
        const label = document.createElement('span');
        label.style.display = 'inline-flex';
        label.style.alignItems = 'center';
        label.style.gap = '5px';
        const title = document.createElement('span');

        title.textContent = ` ${column.getDefinition().title}`;

        label.appendChild(icon);
        label.appendChild(title);
        // const { toggleVisibleColumns } = this;
        // create menu item
        menu.push({
          label,
          action(e) {
            // prevent menu closing
            e.stopPropagation();

            const visibleColumns = columns.filter((item) => item.isVisible()).length;
            if (visibleColumns > 1) {
              // toggle current column visibility
              column.toggle();
            } else if (visibleColumns === 1 && !column.isVisible()) {
              column.toggle();
            }
            // change menu item icon
            if (column.isVisible()) {
              icon.classList.remove('eva-basic_checkbox');
              icon.classList.add('eva-basic_checkbox_checked');
            } else {
              icon.classList.remove('eva-basic_checkbox_checked');
              icon.classList.add('eva-basic_checkbox');
            }
            // toggleVisibleColumns(column.getField());
          },
        });
      }

      return menu;
    },
    toggleVisibleColumns(column) {
      const isVisible = this.visibleColumns.indexOf(column) !== -1;
      const updatedValue = isVisible
        ? this.visibleColumns.filter((el) => el !== column)
        : [...this.visibleColumns, column];
      this.$store.commit('setState', [{
        object: this.getOptions,
        prop: 'titles',
        value: updatedValue,
      }]);
    },
    cellClickEvent(e, { _cell: cell }) {
      // For token\click-event
      const allCellInRow = cell.row.cells
        .map((el) => ({ field: el.column.field, value: el.value }))
        .reduce((acc, cur) => {
          acc[cur.field] = cur.value;
          return acc;
        }, {});
      const data = {
        clickedCell: cell.value,
        allCellInRow,
      };
      this.setToken('click', data);
      // For edit
      // if (e instanceof FocusEvent) {
      //   const column = cell.column.field;
      //   const { value } = cell;
      //   const row = cell.row.position;
      //
      //   this.$emit('cellClick', { row, column, value });
      // }
    },
    writeData() {
      this.tableData = this.tabulator.getData();
      this.$root.writeData({ data: structuredClone(this.tableData), schema: this.searchSchema });
    },
    // undo button
    undo() {
      this.tabulator.undo();
    },
    // redo button
    redo() {
      this.tabulator.redo();
    },
    addDataRow() {
      const newRow = Object.keys(this.searchSchema).reduce((acc, item) => {
        const defaultValue = this.searchSchema[item] === 'BOOLEAN'
          ? false
          : '';
        return {
          ...acc,
          [item]: defaultValue,
        };
      }, {});
      this.tabulator.addRow(newRow);

      this.tableData = this.tabulator.getData();
    },
    removeDataRow() {
      this.tabulator.getSelectedRows().forEach((row) => {
        row.delete();
      });

      this.tableData = this.tabulator.getData();
    },
    // trigger download of data.csv file
    downloadCSV() {
      this.tabulator.download('csv', 'data.csv');
    },
    // trigger download of data.json file
    downloadJSON() {
      this.tabulator.download('json', 'data.json');
    },
    // trigger download of data.xlsx file
    downloadXLSX() {
      this.tabulator.download('xlsx', 'data.xlsx', { sheetName: 'My Data' }, { compress: false });
    },
    // trigger download of data.pdf file
    downloadPDF() {
      this.tabulator.download('pdf', 'data.pdf', {
        orientation: 'portrait', // set page orientation to portrait
      });
    },
    // trigger download of data.html file
    downloadHTML() {
      this.tabulator.download('html', 'data.html', { style: true });
    },
    loadCSV() {
      this.tabulator.importFormat = 'csv';
      this.isLoadFromFile = true;
      this.tabulator.import('csv', '.csv')
        .then(() => {
          this.tableData = this.tabulator.getData();
          this.createTable();
          delete this.tabulator.importFormat;
          this.isLoadFromFile = false;
        })
        .catch(() => {
          this.tableData = [];
        });
    },
    loadJSON() {
      this.tabulator.import('json', '.json')
        .then(() => {
          this.isLoadFromFile = true;
          this.tableData = this.tabulator.getData();
          this.createTable();
        })
        .catch(() => {
          this.tableData = [];
        });
    },
    execute(action) {
      this.isDownloadModal = false;
      this[action]();
    },
    getDataFromTable() {
      return this.tabulator.getData();
    },
    destroyTable() {
      if (this.tabulator) {
        this.tabulator.destroy();
        this.tabulator = null;
      }
    },
    persistenceWriterFunc(id, type, data) {
      if (data?.length > 0 && this.dataRestFrom?.length > 0) {
        if (!this.dashFromStore?.tableOptions) {
          this.$store.commit('setState', [{
            object: this.dashFromStore,
            prop: 'tableOptions',
            value: {},
          }]);
        }
        if (!this.dashFromStore.tableOptions[`${id}-${type}`]) {
          this.$store.commit('setState', [{
            object: this.dashFromStore.tableOptions,
            prop: `${id}-${type}`,
            value: [],
          }]);
        }
        const dataFromStore = this.dashFromStore.tableOptions[`${id}-${type}`];
        if (JSON.stringify(dataFromStore) !== JSON.stringify(data)) {
          this.$store.commit('setState', [{
            object: this.dashFromStore.tableOptions,
            prop: `${id}-${type}`,
            value: structuredClone(data),
          }]);
        }
      }
    },
    persistenceReaderFunc(id, type) {
      const { tableOptions } = this.dashFromStore;
      if (tableOptions && tableOptions[`${id}-${type}`]
          && tableOptions[`${id}-${type}`].length > 0) {
        return structuredClone(tableOptions[`${id}-${type}`]);
      }
      return false;
    },
    getEvents({ event, partelement }) {
      let result = [];
      if (!this.$store.state[this.idDashFrom].events) {
        this.$store.commit('setState', [{
          object: this.$store.state[this.idDashFrom],
          prop: 'events',
          value: [],
        }]);
        return [];
      }
      if (partelement) {
        result = this.$store.state[this.idDashFrom].events.filter((item) => (
          item.event === event
            && item.element === this.idFrom
            && item.partelement === partelement
        ));
      } else {
        result = this.$store.state[this.idDashFrom].events.filter(
          (item) => item.event === event
                && item.target === this.idFrom,
        );
      }
      return result;
    },
    setToken(event, data) {
      const targetTokens = this.getTokens.filter((el) => el.action === event);
      targetTokens.forEach((token) => {
        if (token.capture) {
          this.$store.commit('setTocken', {
            token,
            idDash: this.idDashFrom,
            store: this.$store,
            value: `${data.allCellInRow[token.capture]}`,
          });
        } else {
          this.$store.commit('setTocken', {
            token,
            idDash: this.idDashFrom,
            store: this.$store,
            value: `${data.clickedCell}`,
          });
        }
      });
    },
    setAction(data) {
      this.actions.forEach((action) => {
        action.capture = Object.keys(data);
      });
      this.$store.commit('setActions', {
        actions: structuredClone(this.actions),
        idDash: this.idDashFrom,
        id: this.idFrom,
      });
    },
    onDataCompare() {
      const compareEval = {
        equals: '=',
        over: '>',
        less: '<',
      };

      if (!this.tabulator?.rowManager?.getRows()) {
        return;
      }
      // eslint-disable-next-line no-restricted-syntax
      for (const row of this.tabulator.rowManager.getRows()) {
        if (!row.getCells()) {
          // eslint-disable-next-line no-continue
          continue;
        }

        // eslint-disable-next-line no-restricted-syntax
        for (const cell of row.getCells()) {
          const field = cell.column.getField();
          const event = this.findEvent(field);

          if (!event) {
            // eslint-disable-next-line no-continue
            continue;
          }

          const [eventType, compare, color, secondValue] = event.prop;

          if (eventType !== 'cellcolor') {
            // eslint-disable-next-line no-continue
            continue;
          }

          const targetCell = cell.element;
          const firstValue = cell.getValue();
          const comparisonResult = this.getComparisonResult(
            compareEval[compare],
            { val: firstValue, secondVal: secondValue },
          );

          if (comparisonResult && color) {
            targetCell.style.backgroundColor = color;
            cell.element = targetCell;
          }
        }
      }
    },
    findEvent(field) {
      // eslint-disable-next-line no-restricted-syntax
      for (const event of this.events) {
        if (event.prop[0] === 'cellcolor' && event.column === field) {
          return event;
        }
      }

      return null;
    },
    getComparisonResult(compare, { val, secondVal }) {
      switch (compare) {
        case '>':
          return val > secondVal;
        case '<':
          return val < secondVal;
        case '=':
          return val === secondVal;
        default:
          return false;
      }
    },
  },
};
</script>

<style lang="scss">
@import "../../../scss/tabulator.scss";

.dash-table-v2-container {
  padding: 10px;

  .title {

    color: var(--main_text);
    font-size: 18px;
    font-weight: 700;
    line-height: 25px;
    padding-bottom: 8px;
  }
  &__filter-container {
    display: grid;
    grid-template-columns: 25% 75%;
    gap: 5px;
    padding: 0 8px 0 0;
  }
  &__filter-select {
    border: 1px solid var(--main_border);
    border-radius: 4px;
    color: var(--main_text);
    outline: none;
    text-align: center;
    cursor: pointer;
  }
  &__filter-select-option {
    background-color: var(--main_bg);
    color: var(--main_text);
    outline: none;
    border-left: 2px solid var(--main_border);
    border-right: 2px solid var(--main_border);
    cursor: pointer;
    &:first-child {
      border-top: 2px solid var(--main_border);
    }
    &:last-child {
      border-bottom: 2px solid var(--main_border);
    }
  }
  &__filter-input {
    border: 1px solid var(--main_border);
    border-radius: 4px;
    color: var(--main_text);
    outline: none;
  }
}

/*Theme the this.tabulator element*/
.editable-table {
  *::-webkit-scrollbar {
    width: 10px;
    height: 10px;
  }
  *::-webkit-scrollbar-thumb {
    border-radius: 10px;
    background-color: var(--secondary_text);
  }

  *::-webkit-scrollbar-track {
    -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.2);
    border-radius: 10px;
    background-color: var(--secondary_bg) !important;
  }

  *::-webkit-scrollbar-corner {
    background-color: var(--secondary_bg);
  }

  background-color: transparent!important;
  border: none;
  border-radius: 4px;
  /*Theme the header*/
  .tabulator-header {
    background: transparent!important;
    color: var(--main_text)!important;
    border-color: var(--main_border) !important;

    /*Allow column header names to wrap lines*/
    .tabulator-col,
    .tabulator-col-row-handle {
      background: transparent!important;
      white-space: normal;
    }
    .tabulator-col {
      border-color: var(--main_border) !important;
      &.tabulator-frozen {
        background-color: var(--main_bg) !important;
      }
    }

    .tabulator-header-filter input {
      background-color: transparent;
      border: 1px solid var(--main_border);
      border-radius: 4.44px;
      padding: 6px 6px;
      font-size: 13px;
      line-height: 1.23;
      color: var(--main_text);
      transition: border-color 0.3s, background-color 0.3s;
    }
  }

  .tabulator-row{
    color: var(--main_text)!important;
    background-color: transparent;
    transition: background-color .3s, color .3s;
    border-bottom: 1px solid var(--main_border);
    &.on-data-compare-color {
      background-color: transparent;
    }

    /*Color even rows*/
    &:nth-child(even) {
      background-color: transparent!important;
      &.on-data-compare-color {
        background-color: transparent;
      }
    }
    .tabulator-cell {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: background-color .3s;
      &.tabulator-frozen {
        background-color: var(--main_bg);
      }
    }
    &:hover {
      background-color: var(--main_text) !important;
      cursor: pointer;
      color: var(--main_bg) !important;
      .tabulator-cell {
        background-color: var(--main_text) !important;
      }
    }
    &.tabulator-selectable {
      &.tabulator-selected {
        background-color: var(--main_text) !important;
        cursor: pointer;
        color: var(--main_bg) !important;
        .tabulator-cell {
          background-color: var(--main_text) !important;
        }
      }
    }
  }
  /*Color the table rows*/
  .tabulator-cell {
    border-color: var(--main_border) !important;
  }
  .tabulator-footer {
    background: transparent !important;
    border-top: 1px solid var(--main_border)!important;
    color: var(--main_text)!important;

    .tabulator-paginator {
      color: var(--main_text)!important;
    }

    .tabulator-page-size {
      background-color: var(--main_bg);
      border: 1px solid var(--main_border);
      border-radius: 4.44px;
      //padding: 5px 25px 5px 12px;
      color: var(--main_text);
      transition: border-color 0.3s, background-color 0.3s;
      font-size: 13px;
      line-height: 1.218;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;

      .option {
        cursor: pointer;
        background-color: transparent;
        border-top: 1px solid var(--main_border);
        color: var(--secondary_text);
      }
    }

    .tabulator-page-size:focus-visible {
      outline: none;
    }

    .tabulator-page {
      font-size: 11px;
      padding: 2px 13px;
      border-radius: 4px;
      transition: background-color 0.3s;
      color: var(--main_text);
      background-color: var(--main_bg);
      border: 1px solid var(--main_text);
      opacity: 1!important;
      height: 22px;
      position: relative;

      &:hover {
        background-color: var(--main_text) !important;
        color: var(--main_bg) !important;
        &[data-page="prev"],
        &[data-page="next"],
        &[data-page="last"],
        &[data-page="first"] {
          color: transparent !important;
          &:before {
            color: var(--main_bg) !important;
          }
        }
      }
      &.active
      {
        color: var(--main_text) !important;
        background-color: var(--secondary_bg)!important;
      }
      &[data-page="prev"],
      &[data-page="next"],
      &[data-page="last"],
      &[data-page="first"] {
        color: transparent !important;
       &:before {
         font-family: 'eva-icons' !important;
         speak: never;
         font-style: normal;
         font-weight: normal;
         font-variant: normal;
         text-transform: none;
         line-height: 1;
         /* Better Font Rendering =========== */
         -webkit-font-smoothing: antialiased;
         -moz-osx-font-smoothing: grayscale;
         position: absolute;
         left: 50%;
         top: 50%;
         transform: translate(-50%, -50%);
         width: 15px;
         height: 15px;
         font-size: 15px;
         color: var(--main_text);
         transition: color .3s;
       }
      }
      &[data-page="first"] {
        &:before {
          content: "\e919";
        }
      }
      &[data-page="last"] {
        &:before {
          content: "\e91a";
        }
      }
      &[data-page="next"] {
        &:before {
          content: "\e90e";
        }
      }
      &[data-page="prev"] {
        &:before {
          content: "\e90d";
        }
      }
    }
  }
  .tabulator-frozen-rows-holder {
    border-bottom: 2px solid var(--main_border) !important;
  }
  .tabulator-frozen-left {
    border-right: 2px solid var(--main_border) !important;
  }
  .tabulator-col-title {
    //padding-left: 15px;
    input[type=checkbox] {
      //margin-left: -15px;
    }
  }

}
.tabulator-menu.tabulator-popup-container {
  max-height: 180px;
  text-align: left;
  border-radius: 2px;
  & > .tabulator-menu-item {
    color: var(--main_text)!important;
    background-color: var(--main_bg)!important;
    transition: all 0.3s ease-in-out;

    &:hover {
      background-color: var(--main_text)!important;
      color: var(--main_bg)!important;
    }

  }

}

</style>
