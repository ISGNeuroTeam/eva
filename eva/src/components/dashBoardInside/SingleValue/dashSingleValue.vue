<template>
  <div
    class="single-value-container pa-3"
    :class="{ 'header-active': dataModeFrom }"
  >
    <div class="header">
      <div>
        <span class="data-title" v-text="tokenizedTitle"/>
      </div>
      <v-icon
        v-show="dataModeFrom"
        size="22"
        class="settings-icon"
        @click.stop="openSettings"
        v-text="mdiSettings"
      />
    </div>

    <div class="content pt-3" :class="metricTemplateClass">
      <div
        v-for="(metric, idx) in dataToRender"
        :key="`metric-${metric.id}`"
        class="item"
        :style="{ gridArea: `item-${idx + 1}` }"
      >
        <span class="metric-title">
          <span
            v-show="metric.icon !== 'no_icon'"
            class="icon"
            v-html="getIconSvgByID(metric.icon)"
          />
          <span
            class="title-text"
            v-text="metric.title"
          />
        </span>
        <span
          class="metric-value"
          :class="`color-${metric.color}`"
          :style="`
            color: ${getColor(metric)};
            font-size: ${metric.fontSize || 16}px;
            font-weight: ${metric.fontWeight || 200};
            `"
        >
          <span v-text="metric.value"></span>
        </span>
      </div>
    </div>
    <SingleValueSettings
      :is-open="isSettingsComponentOpen"
      :received-settings="providedSettings"
      :updateCount="updateCount"
      :default-settings="defaultSettings"
      @save="saveSettings"
      @close="closeSettings"
    />
  </div>
</template>

<script>
import SingleValueSettings from './SingleValueSettings';
import metricTitleIcons from './metricTitleIcons';
import { mdiSettings } from '@mdi/js';

export default {
  name: 'singleValue',
  components: { SingleValueSettings },
  props: {
    idFrom: String,
    idDashFrom: String,
    dataRestFrom: Array,
    dataModeFrom: Boolean,
    updateSettings: Function,
    currentSettings: Object
  },
  data: () => ({
    mdiSettings,
    metricTitleIcons,
    titleToken: '',
    options: {},
    metricList: [],
    metricCount: 0,
    template: 1,
    providedSettings: {},
    defaultSettings: {},
    isSettingsComponentOpen: false,
    update: 1,
  }),
  computed: {
    dataToRender() {
      let temp = [...this.metricList].sort((a,b) => a.listOrder - b.listOrder)
      // console.log(temp)
      return this.update && temp.slice(0, this.metricCount);
    },

    theme() {
      return this.$store.getters.getTheme;
    },

    tokenizedTitle() {
      const title = this.options?.settings?.title || '';
      return title.replaceAll('<title>', this.titleToken);
    },

    metricTemplateClass() {
      return `metric-${this.metricCount} v-${this.template}`;
    },
  },
  watch: {
    dataRestFrom() {
      const { idFrom: id, idDashFrom: idDash } = this;
      const options = JSON.parse(JSON.stringify(this.$store.getters.getOptions({ id, idDash })));
      this.setVisual(this.currentSettings.metricOptions.length ? this.currentSettings.metricOptions : options.settings?.metricOptions)

    },
    currentSettings() {
      console.log('currentSettings')
      this.providedSettings = { ... this.currentSettings }
      this.init({ ... this.currentSettings })
    }
  },
  mounted() {
    /** Getting saved component options from the store. */
    this.init(null, true);
  },
  methods: {
    getColor(metric) {
      if (!metric.metadata) {
        return undefined;
      }
      const ranges = eval('({obj:[' + metric.metadata + ']})').obj[0];
      Object.keys(ranges).forEach(key => {
        ranges[key] = ranges[key].split(':').map(Number);
      });


      if (metric.color === 'range') {
        if (Number(metric.value)) {
          const val = Number(metric.value);
          if (val >= ranges.red[0] && val <= ranges.red[1]) {
            return '#FF5147';
          }

          if (val >= ranges.yellow[0] && val <= ranges.yellow[1]) {
            return '#FFE065';
          }

          return '#5BD97A';
        }
      }

      if (metric.color === 'secondary') {
        return '#e0e0ec';
      }

      return '#5980f8';
    },
    init(settings, up) {
      const { idFrom: id, idDashFrom: idDash } = this;
      const options = JSON.parse(JSON.stringify(this.$store.getters.getOptions({ id, idDash })));
      if (!options.settings && !settings) {
        options.settings = {
          title: '',
          template: 1,
          metricCount: this.metricCount || 1,
          metricOptions: [],
        };
      }
      if (this.updateSettings && up) {
        this.updateSettings(settings || options.settings)
      }
      this.providedSettings = settings || options.settings
      const { template, metricCount } = settings || options.settings;

      this.options = {
        ...options,
        settings: settings || options.settings,
      };
      this.template = template;
      this.metricCount = this.metricCount || metricCount;
      this.updateVisual(settings || options.settings)
    },
    updateCount(count) {
      const { idFrom: id, idDashFrom: idDash } = this;
      const options = { ...this.$store.getters.getOptions({ id, idDash }) };
      this.metricCount = count;

      const newSettings = options.settings ? { ...options.settings, metricCount: count } : { metricCount: count }

      this.$store.commit('setOptions', newSettings)
      if (this.updateSettings) {
        this.updateSettings(newSettings)
      }
      
      this.setVisual();
    },
    setVisual(metricOptionsCurrent) {
      const metricList = [];
      const metricOptions = [];
      let idCount = 1;
      // console.log(metricOptionsCurrent, 'metricOptionsCurrent')
      for (const [index, data] of this.dataRestFrom.entries()) {
        const { metric, value, order, metadata } = data;
        if (metric === '_title') {
          this.titleToken = String(value);
          continue;
        }

        const metricID = idCount++;
        let range = metadata;

        if (!metadata || typeof metadata !== 'string') {
          range = null;
        }

        const startId = `${metric}_${idCount}`

        const metricCurrent = metricOptionsCurrent?.find(m => m.startId === startId);
        const defaultMetricOption = {
          id: metricCurrent?.id || metricID,
          startId: metricCurrent?.startId || startId,
          metadata: metadata,
          title: metric || data.phase,
          color: metricCurrent?.color || 'main',
          icon: metricCurrent?.icon || 'no_icon',
          fontSize: metricCurrent?.fontSize || 54,
          fontWeight: metricCurrent?.fontWeight || 400,
          listOrder: metricCurrent?.listOrder === undefined ? order : metricCurrent?.listOrder,
          ...metricCurrent,
        };
        metricList.push({ value, ...defaultMetricOption });
        metricOptions.push({ order, range, expanded: false, ...defaultMetricOption });
      }
      this.metricList = metricList;
      this.options.settings.metricOptions = metricOptions;
    },
    updateVisual(settings) {
      this.metricList = settings.metricOptions.map((item, idx) => ({
        ...item,
        listOrder: idx,
        title: item.name || item.title,
        fontWeight: 400,
        value: this.metricList.find(m => m.startId === item.startId)?.value
      }))

      this.setVisual(settings.metricOptions);
    },
    updateOptions() {
      this.$store.commit('setOptions', {
        id: this.idFrom,
        idDash: this.idDashFrom,
        options: { ...this.options },
      });
    },

    openSettings() {
      /** Updating the settings provided to the SingleValueSettings. */
      this.providedSettings = { ... this.options.settings };
      this.defaultSettings = { ... this.options.settings }
      this.isSettingsComponentOpen = true;
    },

    saveSettings(settings = {}) {
      const { metricCount, template, metricOptions } = settings;
      metricOptions.forEach((item, idx) => {
        item.id = idx + 1;
        item.listOrder = idx + 1;
      });
      const newSettings = { ...settings, metricOptions };
      this.template = template;
      this.metricCount = metricCount;
      /** Applying settings from the SingleValueSettings. */
      this.options.settings = newSettings;

      /** Updated local metricList array. */
      const newMetricList = [];
      for (const [index, updatedMetric] of metricOptions.entries()) {
        const { icon, title, color, fontSize, fontWeight } = updatedMetric;
        const metric = this.metricList.find(m => m.id === updatedMetric.id);
        metric.icon = icon;
        metric.title = title;
        metric.color = color;
        metric.fontSize = fontSize;
        metric.fontWeight = fontWeight;
        metric.listOrder = index;
        newMetricList[index] = metric
      }
      this.metricList = [...newMetricList]
      this.providedSettings = { ...newSettings };

      this.$store.commit('setOptions', {
        id: this.idFrom,
        idDash: this.idDashFrom,
        options: { ...this.options, settings: newSettings },
      });

      if (this.updateSettings)
        this.updateSettings(newSettings)
      this.update++;
    },

    closeSettings() {
      this.isSettingsComponentOpen = false;
    },

    getIconSvgByID(id) {
      const icon = this.metricTitleIcons.find(m => m.id === id);
      return icon?.svg;
    },
  },
};
</script>

<style lang="sass" scoped>
@import './sass/dashSingleValue'
</style>
